from flask import Blueprint, render_template, request, jsonify, current_app, abort, Response
from flask_login import login_required, current_user
import sqlite3
import json
import math
import csv
import io
from functools import wraps
from datetime import datetime, timedelta
from werkzeug.security import generate_password_hash

# --- ðŸ”’ SECURE URL PREFIX ---
admin_bp = Blueprint('admin', __name__, url_prefix='/x7k9-p2m4-z8q1')

# --- CSRF PROTECTION ---
@admin_bp.before_request
def check_csrf_and_origin():
    if request.method == "GET": return
    referer = request.headers.get('Referer')
    allowed_host = request.host 
    if not referer or allowed_host not in referer:
        return jsonify({"error": "CSRF BLOCKED: Invalid Source"}), 403

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_admin:
            return abort(403)
        return f(*args, **kwargs)
    return decorated_function

def get_db():
    return sqlite3.connect(current_app.config['DB_PATH'], timeout=30)

def safe_notify_user(conn, user_id, message, msg_type="info"):
    try:
        c = conn.cursor()
        c.execute("INSERT INTO user_notifications (user_id, message, type) VALUES (?, ?, ?)", (user_id, message, msg_type))
    except Exception as e: print(f"[WARNING] Notification failed: {e}")

@admin_bp.route('/dashboard')
@login_required
@admin_required
def dashboard(): return render_template('admin_dashboard.html', user=current_user)

@admin_bp.route('/api/system/health')
@login_required
@admin_required
def system_health():
    conn = get_db(); c = conn.cursor()
    c.execute("SELECT key, value FROM system_config")
    config = dict(c.fetchall())
    c.execute("SELECT COUNT(*) FROM batches WHERE status IN ('QUEUED', 'PROCESSING')"); q = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM batches WHERE status='CONFIRMING'"); c_active = c.fetchone()[0]
    c.execute("SELECT COUNT(*) FROM batches WHERE status='FAILED' AND created_at > datetime('now', '-1 day')"); err_batch = c.fetchone()[0]
    try: c.execute("SELECT COUNT(*) FROM server_errors WHERE created_at > datetime('now', '-1 day')"); err_sys = c.fetchone()[0]
    except: err_sys = 0
    c.execute("""SELECT SUM(b.success_count * COALESCE(u.price_per_label, 3.00)) FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status IN ('COMPLETED','PARTIAL')"""); rev_live = c.fetchone()[0] or 0.0
    rev_arch = float(config.get('archived_revenue', '0.00')); rev_life = rev_live + rev_arch
    c.execute("""SELECT SUM(b.success_count * COALESCE(u.price_per_label, 3.00)) FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status IN ('COMPLETED','PARTIAL') AND b.created_at > datetime('now', '-30 days')"""); rev_30 = c.fetchone()[0] or 0.0
    c.execute("""SELECT SUM(b.success_count * COALESCE(u.price_per_label, 3.00)) FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status IN ('COMPLETED','PARTIAL') AND b.created_at > datetime('now', '-7 days')"""); rev_7d = c.fetchone()[0] or 0.0
    rev_est_30 = (rev_7d / 7 * 30) if rev_7d > 0 else 0.0
    sub_slots = int(config.get('slots_monthly_used', 0)); sub_price = float(config.get('automation_price_monthly', 29.99)); rev_mrr = sub_slots * sub_price
    conn.close()
    return jsonify({"worker_status": "PAUSED" if config.get('worker_paused')=='1' else "ONLINE", "queue_depth": q, "active_confirmations": c_active, "errors_24h": err_batch + err_sys, "revenue_lifetime": rev_life, "revenue_30d": rev_30, "revenue_est_30d": rev_est_30, "subs_mrr": rev_mrr, "subs_count": sub_slots})

@admin_bp.route('/api/server/errors')
@login_required
@admin_required
def server_errors():
    conn = get_db(); c = conn.cursor()
    try:
        c.execute("SELECT id, source, batch_id, error_msg, created_at FROM server_errors ORDER BY created_at DESC LIMIT 100")
        rows = [{"id":r[0], "source":r[1], "batch":r[2], "msg":r[3], "date":r[4]} for r in c.fetchall()]
    except: rows = []
    conn.close(); return jsonify(rows)

@admin_bp.route('/api/queue/control', methods=['POST'])
@login_required
@admin_required
def queue_control():
    val = '1' if request.json.get('action') == 'pause' else '0'
    conn = get_db(); c = conn.cursor(); c.execute("INSERT OR REPLACE INTO system_config (key, value) VALUES ('worker_paused', ?)", (val,)); conn.commit(); conn.close()
    return jsonify({"status": "success"})

@admin_bp.route('/api/jobs/live')
@login_required
@admin_required
def list_live_jobs():
    conn = get_db(); c = conn.cursor()
    c.execute("SELECT b.batch_id, u.username, b.created_at, b.count, b.success_count, b.status FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status IN ('QUEUED', 'PROCESSING') ORDER BY b.created_at ASC")
    rows = [{"id":r[0], "user":r[1], "date":r[2], "size":r[3], "progress":r[4], "status":r[5]} for r in c.fetchall()]; conn.close()
    return jsonify(rows)

@admin_bp.route('/api/jobs/confirming')
@login_required
@admin_required
def list_confirming_jobs():
    conn = get_db(); c = conn.cursor()
    c.execute("SELECT b.batch_id, u.username, b.created_at, b.count, b.success_count, b.status FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status = 'CONFIRMING' ORDER BY b.created_at ASC")
    rows = [{"id":r[0], "user":r[1], "date":r[2], "size":r[3], "progress":r[4], "status":r[5]} for r in c.fetchall()]; conn.close()
    return jsonify(rows)

@admin_bp.route('/api/jobs/history')
@login_required
@admin_required
def list_history():
    page = int(request.args.get('page', 1)); limit = 20; offset = (page-1)*limit
    search = request.args.get('search', '').strip(); conn = get_db(); c = conn.cursor()
    base = "FROM batches b JOIN users u ON b.user_id = u.id WHERE b.status NOT IN ('QUEUED', 'PROCESSING', 'CONFIRMING')"
    params = []
    if search: base += " AND (b.batch_id LIKE ? OR u.username LIKE ?)"; params.extend([f"%{search}%", f"%{search}%"])
    c.execute(f"SELECT COUNT(*) {base}", params); total = c.fetchone()[0]
    c.execute(f"SELECT b.batch_id, u.username, b.created_at, b.count, b.success_count, b.status, u.price_per_label {base} ORDER BY b.created_at DESC LIMIT ? OFFSET ?", (*params, limit, offset))
    rows = [{"id":r[0], "user":r[1], "date":r[2], "size":r[3], "progress":r[4], "status":r[5], "value": float(r[3])*float(r[6] or 0)} for r in c.fetchall()]
    conn.close(); return jsonify({"data": rows, "current_page": page, "total_pages": math.ceil(total/limit)})

@admin_bp.route('/api/jobs/action', methods=['POST'])
@login_required
@admin_required
def job_action():
    data = request.json; bid = data.get('batch_id'); act = data.get('action'); conn = get_db(); c = conn.cursor()
    if act == 'cancel': c.execute("UPDATE batches SET status='FAILED' WHERE batch_id=?", (bid,))
    elif act == 'retry': c.execute("UPDATE batches SET status='QUEUED' WHERE batch_id=?", (bid,))
    elif act == 'refund':
        c.execute("SELECT user_id, count, status FROM batches WHERE batch_id=?", (bid,)); row = c.fetchone()
        if row and row[2] != 'REFUNDED':
            uid, count = row[0], row[1]
            c.execute("SELECT price_per_label FROM users WHERE id=?", (uid,)); p = c.fetchone(); price = p[0] if p else 3.00
            amt = count * price
            c.execute("UPDATE users SET balance = balance + ? WHERE id=?", (amt, uid))
            c.execute("UPDATE batches SET status='REFUNDED' WHERE batch_id=?", (bid,))
            c.execute("INSERT INTO admin_audit_log (admin_id, action, details, created_at) VALUES (?, ?, ?, ?)", (current_user.id, "REFUND", f"Batch {bid} (${amt})", datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")))
            safe_notify_user(conn, uid, f"REFUND: Batch {bid} (${amt:.2f})", "success")
    conn.commit(); conn.close(); return jsonify({"status": "success"})

@admin_bp.route('/api/users/search', methods=['GET'])
@login_required
@admin_required
def search_users():
    q = request.args.get('q', '').strip(); conn = get_db(); c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM users WHERE is_admin = 0"); total = c.fetchone()[0]
    sql = "SELECT id, username, balance, created_at FROM users WHERE is_admin = 0"
    if q: sql += " AND username LIKE ?"; params = (f"%{q}%",)
    else: params = ()
    c.execute(sql + " ORDER BY id DESC LIMIT 50", params)
    rows = [{"id":r[0], "username":r[1], "balance":r[2], "date":r[3]} for r in c.fetchall()]
    conn.close(); return jsonify({"users": rows, "total": total})

@admin_bp.route('/api/users/details/<int:uid>', methods=['GET'])
@login_required
@admin_required
def user_details(uid):
    conn = get_db(); c = conn.cursor()
    c.execute("SELECT price_per_label, subscription_end, auto_renew FROM users WHERE id=?", (uid,)); u = c.fetchone()
    if not u: conn.close(); return jsonify({}), 404
    c.execute("SELECT ip_address FROM login_history WHERE user_id=? ORDER BY created_at DESC LIMIT 1", (uid,)); ip = c.fetchone()
    c.execute("SELECT label_type, version, price FROM user_pricing WHERE user_id=?", (uid,))
    prices = {f"{r[0]}_{r[1]}": r[2] for r in c.fetchall()}
    
    # --- DEFAULTS FOR NEW VERSIONS ---
    base = u[0]
    if 'priority_95055' not in prices: prices['priority_95055'] = base
    if 'priority_94888' not in prices: prices['priority_94888'] = base
    if 'priority_94019' not in prices: prices['priority_94019'] = base # TEST VERSION
    
    conn.close()
    return jsonify({"ip": ip[0] if ip else "None", "prices": prices, "subscription": {"is_active": u[1] and datetime.strptime(u[1], "%Y-%m-%d %H:%M:%S") > datetime.utcnow(), "end_date": u[1] or "--", "auto_renew": bool(u[2])}})

@admin_bp.route('/api/users/action', methods=['POST'])
@login_required
@admin_required
def user_action():
    data = request.json; act = data.get('action'); uid = data.get('user_id'); conn = get_db(); c = conn.cursor()
    c.execute("SELECT username FROM users WHERE id=?", (uid,)); u_row = c.fetchone(); name = u_row[0] if u_row else "Unknown"
    
    if act == 'update_price':
        l, v, p = data.get('label_type'), data.get('version'), float(data.get('price'))
        c.execute("DELETE FROM user_pricing WHERE user_id=? AND label_type=? AND version=?", (uid, l, v))
        c.execute("INSERT INTO user_pricing (user_id, label_type, version, price) VALUES (?,?,?,?)", (uid, l, v, p))
        if l == 'priority' and v == '95055': c.execute("UPDATE users SET price_per_label=? WHERE id=?", (p, uid))
        safe_notify_user(conn, uid, f"PRICE UPDATE: {v} is now ${p}", "success")
        
    elif act == 'update_balance':
        amt = float(data.get('amount')); c.execute("UPDATE users SET balance = balance + ? WHERE id=?", (amt, uid))
        c.execute("SELECT balance FROM users WHERE id=?", (uid,)); new_bal = c.fetchone()[0]
        c.execute("INSERT INTO admin_audit_log (admin_id, action, details, created_at) VALUES (?, ?, ?, ?)", (current_user.id, "BALANCE_ADJUST", f"{name} {amt}", datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")))
        safe_notify_user(conn, uid, f"BALANCE ADJUSTMENT: ${amt:+.2f}", "success" if amt > 0 else "error")
        conn.commit(); conn.close(); return jsonify({"status":"success", "new_balance": new_bal})

    elif act == 'reset_pass':
        c.execute("UPDATE users SET password_hash=? WHERE id=?", (generate_password_hash(data.get('new_password')), uid))
    elif act == 'grant_sub':
        d = int(data.get('days', 30)); end = (datetime.utcnow() + timedelta(days=d)).strftime("%Y-%m-%d %H:%M:%S")
        c.execute("UPDATE users SET subscription_end=?, auto_renew=0 WHERE id=?", (end, uid))
    elif act == 'revoke_sub':
        c.execute("UPDATE users SET subscription_end=NULL, auto_renew=0 WHERE id=?", (uid,))

    conn.commit(); conn.close()
    return jsonify({"status": "success"})